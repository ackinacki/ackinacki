// 2022-2024 (c) Copyright Contributors to the GOSH DAO. All rights reserved.
//

use std::borrow::Borrow;
use std::collections::HashMap;
use std::collections::HashSet;
use std::sync::Arc;

use database::documents_db::SerializedItem;
use parking_lot::Mutex;
use tvm_block::ShardStateUnsplit;
use tvm_types::UInt256;

use super::accounts::AccountsRepository;
use super::repository_impl::RepositoryImpl;
use super::repository_impl::RepositoryMetadata;
use crate::bls::envelope::Envelope;
use crate::bls::GoshBLS;
use crate::message::identifier::MessageIdentifier;
#[cfg(test)]
use crate::message::message_stub::MessageStub;
use crate::message::WrappedMessage;
use crate::multithreading::cross_thread_messaging::thread_references_state::ThreadReferencesState;
use crate::node::associated_types::AttestationData;
use crate::node::block_state::repository::BlockState;
use crate::node::block_state::repository::BlockStateRepository;
use crate::node::services::sync::StateSyncService;
use crate::node::shared_services::SharedServices;
use crate::node::unprocessed_blocks_collection::UnfinalizedCandidateBlockCollection;
use crate::node::NodeIdentifier;
use crate::repository::optimistic_state::OptimisticState;
use crate::repository::CrossThreadRefData;
use crate::repository::Repository;
#[cfg(test)]
use crate::storage::MessageDBWriterService;
use crate::storage::MessageDurableStorage;
use crate::types::AccountAddress;
use crate::types::AccountRouting;
use crate::types::AckiNackiBlock;
use crate::types::BlockIdentifier;
use crate::types::BlockInfo;
use crate::types::BlockSeqNo;
use crate::types::ThreadIdentifier;
use crate::types::ThreadsTable;
use crate::utilities::FixedSizeHashSet;

#[cfg(test)]
#[derive(Clone)]
pub struct OptimisticStateStub {
    _key: u64,
    _acc: u16,
    _state: tvm_block::Account,
}

#[cfg(test)]
impl OptimisticState for OptimisticStateStub {
    type Cell = ();
    type Message = MessageStub;
    type ShardState = ShardStateUnsplit;

    fn get_share_stare_refs(&self) -> HashMap<ThreadIdentifier, BlockIdentifier> {
        todo!()
    }

    fn get_block_seq_no(&self) -> &BlockSeqNo {
        todo!()
    }

    fn get_block_id(&self) -> &BlockIdentifier {
        todo!()
    }

    fn serialize_into_buf(self) -> anyhow::Result<Vec<u8>> {
        todo!()
    }

    fn get_shard_state(&self) -> Self::ShardState {
        todo!()
    }

    fn get_block_info(&self) -> &BlockInfo {
        todo!()
    }

    fn get_shard_state_as_cell(&self) -> Self::Cell {
        todo!()
    }

    fn apply_block(
        &mut self,
        _block_candidate: &AckiNackiBlock,
        _shared_services: &SharedServices,
        _block_state_repo: BlockStateRepository,
        _nack_set_cache: Arc<Mutex<FixedSizeHashSet<UInt256>>>,
        _accounts_repo: AccountsRepository,
        _message_db: MessageDurableStorage,
    ) -> anyhow::Result<(
        CrossThreadRefData,
        HashMap<AccountAddress, Vec<(MessageIdentifier, Arc<WrappedMessage>)>>,
    )> {
        todo!()
    }

    fn get_thread_id(&self) -> &ThreadIdentifier {
        todo!()
    }

    fn get_produced_threads_table(&self) -> &ThreadsTable {
        todo!()
    }

    fn set_produced_threads_table(&mut self, _table: ThreadsTable) {
        todo!()
    }

    fn crop(
        &mut self,
        _thread_identifier: &ThreadIdentifier,
        _threads_table: &ThreadsTable,
        _message_db: MessageDurableStorage,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn get_thread_for_account(
        &self,
        _account_routing: &AccountRouting,
    ) -> anyhow::Result<ThreadIdentifier> {
        todo!()
    }

    fn does_routing_belong_to_the_state(&self, _account_routing: &AccountRouting) -> bool {
        todo!()
    }

    fn get_internal_message_queue_length(&self) -> usize {
        todo!()
    }

    fn does_state_has_messages_to_other_threads(&mut self) -> anyhow::Result<bool> {
        todo!()
    }

    // fn add_messages_from_ref(
    // &mut self,
    // _cross_thread_ref: &CrossThreadRefData,
    // ) -> anyhow::Result<()> {
    // todo!()
    // }
    fn add_slashing_messages(
        &mut self,
        _slashing_messages: Vec<Arc<Self::Message>>,
    ) -> anyhow::Result<()> {
        todo!()
    }

    // fn add_accounts_from_ref(
    // &mut self,
    // _cross_thread_ref: &CrossThreadRefData,
    // ) -> anyhow::Result<()> {
    // todo!()
    // }

    fn get_thread_refs(&self) -> &ThreadReferencesState {
        todo!()
    }
}

#[cfg(test)]
pub struct RepositoryStub {
    _storage: HashMap<BlockIdentifier, Envelope<GoshBLS, AckiNackiBlock>>,
    optimistic_state: HashMap<BlockIdentifier, <Self as Repository>::OptimisticState>,
}

#[cfg(test)]
impl Default for RepositoryStub {
    fn default() -> Self {
        Self::new()
    }
}

impl RepositoryStub {
    pub fn new() -> Self {
        Self { _storage: HashMap::new(), optimistic_state: HashMap::new() }
    }
}

#[cfg(test)]
impl From<Vec<u8>> for OptimisticStateStub {
    fn from(_value: Vec<u8>) -> Self {
        todo!()
    }
}

#[cfg(test)]
impl From<OptimisticStateStub> for Vec<u8> {
    fn from(_val: OptimisticStateStub) -> Self {
        todo!()
    }
}

#[cfg(test)]
impl Repository for RepositoryStub {
    type Attestation = Envelope<GoshBLS, AttestationData>;
    type BLS = GoshBLS;
    type CandidateBlock = Envelope<GoshBLS, AckiNackiBlock>;
    type EnvelopeSignerIndex = u16;
    type NodeIdentifier = NodeIdentifier;
    type OptimisticState = OptimisticStateStub;
    type StateSnapshot = OptimisticStateStub;

    fn get_message_db(&self) -> MessageDurableStorage {
        todo!()
    }

    fn get_message_storage_service(&self) -> &MessageDBWriterService {
        todo!()
    }

    fn has_thread_metadata(&self, _thread_id: &ThreadIdentifier) -> bool {
        todo!()
    }

    fn load_sent_attestations(
        &self,
    ) -> anyhow::Result<HashMap<ThreadIdentifier, Vec<(BlockSeqNo, Self::Attestation)>>> {
        todo!()
    }

    fn get_finalized_block(
        &self,
        _identifier: &BlockIdentifier,
    ) -> anyhow::Result<Option<Arc<Self::CandidateBlock>>> {
        todo!();
    }

    fn get_block_from_repo_or_archive(
        &self,
        _block_id: &BlockIdentifier,
        _thread_id: &ThreadIdentifier,
    ) -> anyhow::Result<Arc<<Self as Repository>::CandidateBlock>> {
        todo!()
    }

    fn init_thread(
        &mut self,
        _thread_id: &ThreadIdentifier,
        _parent_block_id: &BlockIdentifier,
    ) -> anyhow::Result<()> {
        todo!();
    }

    fn select_thread_last_finalized_block(
        &self,
        _thread_id: &ThreadIdentifier,
    ) -> anyhow::Result<Option<(BlockIdentifier, BlockSeqNo)>> {
        todo!();
    }

    fn is_block_suspicious(&self, _block_id: &BlockIdentifier) -> anyhow::Result<Option<bool>> {
        todo!()
    }

    fn mark_block_as_finalized(
        &mut self,
        _block: impl Borrow<Self::CandidateBlock>,
        _block_state: BlockState,
        _state_sync_service: Option<Arc<impl StateSyncService<Repository = RepositoryImpl>>>,
    ) -> anyhow::Result<()> {
        Ok(())
    }

    //    fn is_block_finalized(&self, _block_id: &BlockIdentifier) -> anyhow::Result<Option<bool>> {
    // Ok(None)
    // }

    fn get_optimistic_state(
        &self,
        block_id: &BlockIdentifier,
        _thread_id: &ThreadIdentifier,
        _min_seq_no: Option<Arc<OptimisticStateStub>>,
    ) -> anyhow::Result<Option<Arc<OptimisticStateStub>>> {
        Ok(self.optimistic_state.get(block_id).map(|s| Arc::new(s.to_owned())))
    }

    fn get_full_optimistic_state(
        &self,
        block_id: &BlockIdentifier,
        _thread_id: &ThreadIdentifier,
        _min_state: Option<Arc<Self::OptimisticState>>,
    ) -> anyhow::Result<Option<Arc<Self::OptimisticState>>> {
        Ok(self.optimistic_state.get(block_id).map(|s| Arc::new(s.to_owned())))
    }

    fn erase_block(
        &self,
        _block_id: &BlockIdentifier,
        _thread_id: &ThreadIdentifier,
    ) -> anyhow::Result<()> {
        todo!()
    }

    // fn set_optimistic_as_is(&self, _optimistic: Self::OptimisticState) ->
    // anyhow::Result<()> { todo!()
    // }

    fn is_block_already_applied(&self, _block_id: &BlockIdentifier) -> anyhow::Result<bool> {
        todo!()
    }

    fn set_state_from_snapshot(
        &mut self,
        _snapshot: Self::StateSnapshot,
        _thread_id: &ThreadIdentifier,
        _skipped_attestation_ids: Arc<Mutex<HashSet<BlockIdentifier>>>,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn sync_accounts_from_state(
        &mut self,
        _shard_state: Arc<ShardStateUnsplit>,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn save_account_diffs(
        &self,
        _block_id: BlockIdentifier,
        _accounts: HashMap<String, SerializedItem>,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn store_optimistic<T: Into<Arc<Self::OptimisticState>>>(
        &self,
        _state: T,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn store_optimistic_in_cache<T: Into<Arc<Self::OptimisticState>>>(
        &self,
        _state: T,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn get_latest_block_id_with_producer_group_change(
        &self,
        _thread_id: &ThreadIdentifier,
    ) -> anyhow::Result<BlockIdentifier> {
        todo!()
    }

    fn clear_verification_markers(
        &self,
        _starting_block_id: &BlockSeqNo,
        _thread_id: &ThreadIdentifier,
    ) -> anyhow::Result<()> {
        todo!()
    }

    fn get_zero_state_for_thread(
        &self,
        _thread_id: &ThreadIdentifier,
    ) -> anyhow::Result<Arc<Self::OptimisticState>> {
        todo!()
    }

    fn get_all_metadata(&self) -> RepositoryMetadata {
        todo!()
    }

    fn last_finalized_optimistic_state(
        &self,
        _thread_id: &ThreadIdentifier,
    ) -> Option<Arc<Self::OptimisticState>> {
        todo!()
    }

    fn unfinalized_blocks(
        &self,
    ) -> Arc<Mutex<HashMap<ThreadIdentifier, UnfinalizedCandidateBlockCollection>>> {
        todo!()
    }
}
